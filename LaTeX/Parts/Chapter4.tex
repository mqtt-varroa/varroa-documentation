\chapter{Scenario Concept}

%\begin{lstlisting}[caption={Implementierung des Trainierens der Markov-Chain}, captionpos=b, label={lst:train}, language=XML]
% <!-- -->
%\end{lstlisting}


\begin{lstlisting}[caption={XML definition of the Scenario}, captionpos=b, label={lst:scenario}, language=XML]
<scenario>
	<broker id="b1">
		<!-- definition broker parameters -->
	</broker>
	
	<clientGroups>
		<!-- definition of client groups -->
	</clientGroups>
	
	<topicGroups>
		<!-- definition of topic groups -->
	</topicGroups>
	
	<subscriptions>
		<!-- definition of subscriptions -->
	</subscriptions>

	<waitPatterns>
		<!-- definition of waitPatterns -->
	</waitPatterns>
	
	<stages>
		<!-- definition of stages -->
	</stages>
</scenario>
\end{lstlisting}

A Varroa test is the execution of a user defined Scenario, which is specified in a XML file.
To define a valid scenario the user needs to define the topology of the Scenario and the behaviour of its components.
An example for the outline of a Scenario XML file is given in \ref{lst:scenario}.

\section{Broker}
\begin{lstlisting}[caption={XML definition of the Broker}, captionpos=b, label={lst:broker}, language=XML]
<scenario>
	<broker id="b1">
		<address>broker.hivemq.com</address>
		<port>1883</port>
	</broker>
</broker>
\end{lstlisting}
The broker is the central component whose performance and stress resistance is tested by the Scenario.
For this the user needs to define:
\begin{itemize}
	\item \textbf{id:} the identifier to reference the broker.
	\item \textbf{address:} the address of the broker can either be a IPv4-Address or a Fully-Qualified-Domain-Name.
	\item \textbf{port:} the port on which the broker is waiting for connections.
\end{itemize}

\section{Client Groups}
\begin{lstlisting}[caption={XML definition of Client Groups}, captionpos=b, label={lst:clientGroups}, language=XML]
<scenario>
	<clientGroups>
		<clientGroup id="cg1">
			<clientIdPattern>A[1-9]+</clientIdPattern>
			<count>100</count>
			<mqtt>
				<!-- MQTT properties -->
			</mqtt>
		</clientGroup>

		<!-- definition of more client groups -->
</scenario>
\end{lstlisting}
A Scenario contains a number of Client Groups.
A Client Group is a specific amount of MQTT Clients that share the exact same behaviour.
When defining a client group the user needs to specify:
\begin{itemize}
	\item \textbf{id:} the identifier to reference the Client Group.
	\item \textbf{clientIdPattern:} a regular expression to create individual names for every MQTT client in the Client Group.
	\item \textbf{count:} the amount of MQTT clients contained in the Client Group.
	\item \textbf{mqtt:} MQTT properties of the MQTT clients. (see \ref{sec:mqttProperties})
\end{itemize}

\subsection{MQTT Properties}\label{sec:mqttProperties}
\begin{lstlisting}[caption={XML definition of MQTT properties}, captionpos=b, label={lst:mqttProperties}, language=XML]
<mqtt>
	<version>5</version>
<\mqtt>
\end{lstlisting}
%	<cleanStart>true</cleanStart>
%	<sessionExpiryInterval>0x0</sessionExpiryInterval>
%</mqtt>	
%\end{lstlisting}
The following MQTT properties can be defined:
\begin{itemize}
	\item \textbf{version (requrired):} the MQTT version this Client Group implements.
	%TODO \item \textbf{cleanStart (optional):} 
	%TODO \item \textbf{sessionExpiryInterval (optional):}
\end{itemize}


\section{Topic Groups} \label{sec:topicGroups}
\begin{lstlisting}[caption={XML definition of Topic Groups}, captionpos=b, label={lst:topicGroups}, language=XML]
<scenario>
	<topicGroups>
		<topicGroup id="tg1">
			<topicNamePattern>topic/subtopic-[0-9]</topicNamePattern>
			<count>10</count>
		</topicGroup>

		<!-- definition of more topic groups -->
	</topicGroups>
</scenario>
\end{lstlisting}
A Scenario contains a number of Topic Groups.
A Topic Group is a specific amount of MQTT Topics whose names are created from the same regular expression.
When defining a Topic Group the user needs to specify:
\begin{itemize}
	\item \textbf{id:} the identifier to reference the Topic Group.
	\item \textbf{topicNamePattern:} a regular expression to create individual topic names for every member of the Topic Group.
	\item \textbf{count:} the amount of MQTT topics in the topic group.
\end{itemize}

\section{Subscriptions} \label{sec:subscriptions}
\begin{lstlisting}[caption={XML definition of subscriptions}, captionpos=b, label={lst:subscriptions}, language=XML]
<scenario>
	<subscriptions>
		<subscription id="sub-1">
			<topicGroup>tg1</topicGroup>
			<wildCard>false</wildCard>
		</subscription>

		<subscription id="sub-2">
			<topicFilter>/topic/subtopic/subsubtopic/#</topicFilter>
		</subscription>

		<!-- definition of more subscriptions -->
	</subscriptions>
</scenario>
\end{lstlisting}
A Scenario can contain Subscriptions.
A Subscription defines a certain subscription behaviour that Client Groups can implement in their Subscribe Commands.
A Subscription can either target Topics that match a specific Topic Filter or a referenced Topic Group.
To define a Topic Group the user needs to specify:
\begin{itemize}
	\item \textbf{id:} the identifier to reference the Subscription.
	\item \textbf{topicFilter:} the Topic Filter to target specific Topics.
\end{itemize}
or
\begin{itemize}
	\item \textbf{id:} the identifier to reference the Subscription.
	\item \textbf{topicGroup:} reference to a Topic Group.
	\item \textbf{wildCard:} whether the Subscription contains a wild card. 
\end{itemize}

\section{Wait Patterns} \label{sec:waitPatterns}
\begin{lstlisting}[caption={XML definition of waitPatterns}, captionpos=b, label={lst:waitPatterns}, language=XML]
<scenario>
	<waitPatterns>
		<waitPattern id="waitPattern-1">
			<subscription>subscription-1</subscription>
			<messagePattern>payload[0-9]{10}</messagePattern>
		</waitPattern>
	</waitPatterns>
</scenario>
\end{lstlisting}
A Wait Pattern enables the user to module waiting behaviours where MQTT clients wait for receiving messages in a Subscription (see \ref{sec:subscriptions}) before executing other commands.
As seen in the example above, the following parameters need to be specified:
\begin{itemize}
	\item \textbf{id:} the identifier to reference the Wait Pattern.
	\item \textbf{subscription:} the Subscription the Wait Pattern targets.
	\item \textbf{messagePattern (optional):} the message pattern that is waited for in the targeted subscription.
\end{itemize}

\section{Stages}
\begin{lstlisting}[caption={XML definition of Stages}, captionpos=b, label={lst:stages}, language=XML]
<scenario>
	<stages>
		<stage id="s1" expectedDuration="10s">
			<lifecycle id="s1.l1" clientGroupId="cg1">
				<!-- definition of commands -->
			</lifecycle>
	
			<!-- definition of more lifecycles -->
		</stage>
	
		<!-- definition of more stages -->
	</stages>
</scenario>
\end{lstlisting}
A Scenario is divided into one or more Stages.
These Stages are executed in sequential order as they are specified in the XML document.
A Stage contains a number of Lifecycles, which specify the behaviour of Client Groups in the stage.
Lifecycles within a stage are executed in parallel.
To define a stage the user needs to specify:
\begin{itemize}
	\item \textbf{id:} the identifier to reference the Stage.
	\item \textbf{expectedDuration (optional):} the expected amount of time this action takes to be executed by the whole Client Group. Used for reporting
\end{itemize}
A Lifecycle contains an amount of Commands (see \ref{sec:commands}). To define a Lifecycle the user needs to specify:
\begin{itemize}
	\item \textbf{id:} the identifier to reference the Lifecycle.
	\item \textbf{clientGroupId:} the Client Group that executes this Lifecycle.
\end{itemize}

\section{Commands}\label{sec:commands}
\subsection{connect}
\begin{lstlisting}[caption={XML definition of a connect command}, captionpos=b, label={lst:connect}, language=XML]
<connect broker="b1" expectedDuration="10s"/>
\end{lstlisting}
A connect command can have the following parameters:
\begin{itemize}
	\item \textbf{broker (required):} the broker the Client Group connects to.
	\item \textbf{expectedDuration (optional):} the expected amount of time this action takes to be executed by the whole Client Group. Used for reporting.
\end{itemize}

\subsection{disconnect}
\begin{lstlisting}[caption={XML definition of a disconnect command}, captionpos=b, label={lst:disconnect}, language=XML]
<disconnect/>
\end{lstlisting}
A disconnect command does not have any parameters.
The Client Group disconnects from the broker it is connected to.

\subsection{publish}
\begin{lstlisting}[caption={XML definition of a publish commmand}, captionpos=b, label={lst:publish}, language=XML]
<publish topicGroup="tg1" count="10" message="message" rate="100/1s"/>
<publish topicGroup="tg1" count="10" payloadGenerator="randomAlphaNumeric"/>
<publish topicGroup="tg1" message="{{clientId}}" payloadGenerator="mustache"/>
<publish topicGroup="tg1" message="payload[0-9]{10}" payloadGenerator="regex"/>
\end{lstlisting}
A publish command has the following parameters:
\begin{itemize}
	\item \textbf{topicGroup (required):} references the Topic Group the message is published to (see \ref{sec:topicGroups}). 
	\item \textbf{message (optional):} the argument for the payloadGenerator.
	\item \textbf{payloadGenerator (optional):} the generator for the payload that is sent within the message. The following options exist:
		\begin{itemize}
			\item \textbf{randomAlphaNumeric:} generates random alpha numeric strings as payloads.
			\item \textbf{static (default):} simply uses the message parameter as payload.
			\item \textbf{mustache:} generates payloads bases on a mustache.js templates given in the message parameter.
			\item \textbf{regex:} generates payloads based on a regex pattern given in the message parameter.
		\end{itemize}
	\item \textbf{qos (optional):} the quality of service.
	\item \textbf{waitForACK (optional):} whether the Client Group waits for the ACK from the broker.
	\item \textbf{count (required when a rate is given):} the amount of publishes.
	\item \textbf{rate (optional):} the rate at witch the publishes are executed.
	\item \textbf{expectedDuration (optional):} the expected amount of time this action takes to be executed by the whole Client Group. Used for reporting.
\end{itemize}

\subsection{subscribe}
\begin{lstlisting}[caption={XML definition of a subscibe command}, captionpos=b, label={lst:subscirbe}, language=XML]
<subscribe subscription="sub1" qos="1"/>
\end{lstlisting}
A subscribe command has the following parameters:
\begin{itemize}
	\item \textbf{subscription (required):} references the subscription to be executed (see \ref{sec:subscriptions}).
	\item \textbf{qos (optional):} the quality of service.
	\item \textbf{expectedDuration (optional):} the expected amount of time this action takes to be executed by the whole Client Group. Used for reporting.
\end{itemize}

\subsection{unsubscribe}
\begin{lstlisting}[caption={XML definition of a unsubscibe command}, captionpos=b, label={lst:unsubscirbe}, language=XML]
<unsubscribe subscription="sub1"/>
\end{lstlisting}
A unsubscribe command has the following parameters:
\begin{itemize}
	\item \textbf{subscription (required):} references the subscription to be terminated (see \ref{sec:subscriptions}).
	\item \textbf{expectedDuration (optional):} the expected amount of time this action takes to be executed by the whole Client Group. Used for reporting.
\end{itemize}

\subsection{wait}
\begin{lstlisting}[caption={XML definition of a wait command}, captionpos=b, label={lst:wait}, language=XML]
<wait topicGroup="tg1" duration="10s"/>
\end{lstlisting}
A wait command has the following parameter:
\begin{itemize}
	\item \textbf{waitPattern (optional):} references the wait pattern (see \ref{sec:waitPatterns}) to waited for.
	\item \textbf{duration (optinal):} the amount of time to wait.
	\item \textbf{expectedDuration: (optional):} the expected amount of time this action takes to be executed by the whole Client Group. Used for reporting.
\end{itemize}

\subsection{for}
\begin{lstlisting}[caption={XML definition of a for command}, captionpos=b, label={lst:for}, language=XML]
<for times="2">
	<connect broker="b1"/>
	<disconnect/>
</for>
\end{lstlisting}
A for command can contain other commands, it has the following parameters:
\begin{itemize}
	\item \textbf{times:} the amount of times the inner commands are executed.
	\item \textbf{rate:} the rate at which the inner commands are executed.
	\item \textbf{expectedDuration: (optional):} the expected amount of time this action takes to be executed by the whole Client Group. Used for reporting.
\end{itemize}

\subsection{rampUp}
\begin{lstlisting}[caption={XML definition of a rampUp command}, captionpos=b, label={lst:rampUp}, language=XML]
<rampUp duration="10s"/>	
\end{lstlisting}
\begin{itemize}
	\item \textbf{duration:} the amount of time the rampUp takes.
\end{itemize}
%TODO specify rampUp behaviour


