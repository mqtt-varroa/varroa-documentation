\chapter{Execution}\label{sec:Execution}
To start a Varroa test the user needs to start a Commander and at least one Agent.
The Agents periodically try to establish a connection to the Commander.
Once all Agents are connected the execution of the scenario starts.\\
\\
Varroa has two main modes of execution for now. One is to configure Varroa ahead of time manually or programmatically and then execute directly. The other is to use containers and utilize dynamic discovery.
\section{Commander}
\begin{figure}[H]
	\begin{center}
	\includegraphics[scale=0.9]{Resources/PDF/CommanderStates}
	\caption{Commander States}
	\label{pic:CommanderStates}
	\end{center}
\end{figure}
After starting a Varroa Instance that is configured as a Commander (see \ref{sec:commanderConfig}) it waits for the Agents to connect.
Until all Agents are successfully connected the Commander remains in the \emph{Waiting for Agents} state.
As the last missing Agent connects the Commander switches its state to \emph{All Agents Connected}.
Then it parses the Scenario's XML. As soon is this is done, the Commander starts to distribute the Scenario's first stage to the Agents.
In doing so the Commander changes its state to \emph{Scenario in Progress}.
It remains in this state until all stages are executed successfully and then transfers its state into \emph{Scenario Finished}.
Contrary to this case a faulty execution of a stage results in the failure of the whole Scenario, logically the Commanders state is then \emph{Scenario Failed}.
To allow better comprehension figure \ref{pic:CommanderStates} illustrates this process.

\subsection{Agent}
\begin{figure}[H]
	\begin{center}
	\includegraphics[scale=0.9]{Resources/PDF/AgentStates}
	\caption{Agent States}
	\label{pic:AgentStates}
	\end{center}
\end{figure}
Upon starting a Varroa Instance as an Agent, it tries to connect to the configured Commander (see \ref{sec:agentConfig}).
It periodically attempts to establish the connection until it succeeds.
Then it waits for incoming Chunks from the Commander and executes them, implementing the handshake protocol introduced in \ref{sec:chunkDistribution}.
The Agent continues doing so until it loses the connection to the Commander.\\
In contrast to the Commander the Agents life-cycle does not stop after the execution of a Scenario.
Because of this the user only needs to restart the Commander to execute another Scenario.
For better understanding of the temporal processes the just explained concepts are illustrated in figure \ref{pic:AgentStates}.

\section{Configuration}
Following are the two sequence sketches for direct (static initialization) configuration \ref{pic:staticExecution} and dynamic (DNS discovery based) \ref{pic:dynamicExecution} configuration.

\subsection{Static configuration}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=1]{Resources/PDF/ExecutionStaticInit}
\caption{static execution}
\label{pic:staticExecution}
\end{center}
\end{figure}

Static configuration may be used on any infrastructure where hostname or IP addresses of all Varroa instances (Commander and Agents) are known ahead of time. This is the case on most typical systems, such as IaaS clouds where an instance is booted and assigned an address before the application is deployed onto that system.\\
\\
For static configuration, the user must provide an instance configuration, which configures the Varroa instance as a Commander or an Agent.
A detailed description of those configuration options can be found in the paragraphs below.
%(or possibly both), as well as (optionally) the instance limits specifying how much load the Agent can generate.

\subsubsection{Commander}\label{sec:commanderConfig}
\begin{lstlisting}[caption={Commander XML configuration example}, captionpos=b, label={lst:commanderConfig}, language=XML]
<varroa>
    <commander>
		<bind-host>192.127.0.1</bind-host>
        <bind-port>12345</bind-port>
        <amount-agents>3</amount-agents>
    </commander>
</varroa>
\end{lstlisting}
\begin{itemize}
	\item \textbf{bind-host:} specifies the Address the Commander binds to
	\item \textbf{bind-port:} specifies the port the Commander binds to for waiting for Agent connections
	\item \textbf{amount-agents:} specifies the amount of Agents that connect to the Commander
\end{itemize}

\subsubsection{Agent}\label{sec:agentConfig}
\begin{lstlisting}[caption={Agent XML configuration example}, captionpos=b, label={lst:agentConfig}, language=XML]
<varroa>
    <agent>
		<commander-host>192.127.0.1</commander-host>
        <commander-port>12345</commander-port>
        <local-port>23458</local-port>
		<commander-retry-interval>10</commander-retry-interval>
    </agent>
</varroa>
\end{lstlisting}
\begin{itemize}
	\item \textbf{commander-port:} specifies the port of the Commander
	\item \textbf{commander-host:} specifies the Address of the Commander
	\item \textbf{local-port:} specifies the local port the Agent uses for the outgoing connection to the Commander %TODO must be different on every Agent
	\item \textbf{commander-retry-interval:} the time interval in which Agents try to connect to the Commander
\end{itemize}

\section{Dynamic configuration}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=1]{Resources/PDF/ExecutionDnsInit}
\caption{dynamic execution}
\label{pic:dynamicExecution}
\end{center}
\end{figure}

DNS discovery specifically is aimed at container environments and cloud platforms. These types of platforms generally provide different methods of service discovery, which are necessary to allow the parts of a distributed systems to communicate with each other.

In container environments especially, the address of a server an application is going to run on is generally not known ahead of application startup. Containers are launched quickly and in an unpredictable order, leading to a scenario where the addresses of all parts of a system cannot be known ahead of time. This necessitates a configuration method which allows service discovery after application startup, which the previous method cannot handle.

Dynamic configuration allows Varroa to start without knowing the addresses of any other Varroa instances nor its own role. The way the initial DNS discovery method works is by supplying hostnames for the commander and agent groups respectively.


\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{Resources/PDF/ExecutionDnsDiscovery}
\caption{agent record resolution}
\end{center}
\end{figure}

At startup Varroa will continuously resolve those records, which must be a round-robin A record, and compare each address found in the records to the address corresponding to its own hostname. If any address matches its own, the instance will set its role according to the set of addresses it matches.

Additionally, agents can use the commander address to locate the commander node and continuously attempt to connect to it until it is ready for agent connections.

The commander can also determine how many agents will connect to it using the agent address, or alternatively a agent count can be  provided at startup (for deployments on services where records are slowly updated as containers start).

\begin{figure}
\begin{lstlisting}
VARROA_DNS_AGENT=tasks.agents
VARROA_DNS_COMMANDER=tasks.commander
VARROA_DNS_AGENT_COUNT=3
\end{lstlisting}
\caption{A sample dynamic discovery configuration, showing the environment variable values}
\end{figure}